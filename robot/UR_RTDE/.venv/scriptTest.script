def q_from_input_float_registers(register_index):
    q = [0, 0, 0, 0, 0, 0]
    q[0] = read_input_float_register(register_index + 0)
    q[1] = read_input_float_register(register_index + 1)
    q[2] = read_input_float_register(register_index + 2)
    q[3] = read_input_float_register(register_index + 3)
    q[4] = read_input_float_register(register_index + 4)
    q[5] = read_input_float_register(register_index + 5)
    return q
  end


thread servo_thread():
    while (True):
        enter_critical
        if (get_inverse_kin_has_solution(a) and is_within_safety_limits(a)):
            q = get_inverse_kin(a)
            dt = 0.002 #1/500
            lh_time = 0.1
            g = 100
        end
        exit_critical
        servoj(q, t=dt, lookahead_time=lh_time, gain=g)
        
    end
end


thread gripper_thread():
  while (True):
    rq_move(read_input_float_register(30))

  end
end



movej([-1.57, -1.57, -1.57, -1.57, 1.57, 0])
rq_activate_and_wait()
rq_auto_release_close_and_wait()

a = get_actual_tcp_pose()
old = 0
grp_move = 0

servo_thrd = run servo_thread()
grp_thrd = run gripper_thread()



while(True):
    b = q_from_input_float_registers(24)
    stop = read_input_float_register(46)
    pkt_nmbr = read_input_float_register(47)
    grp_move = read_input_float_register(30)
    if (stop == 1):
        kill servo_thrd
        kill grp_thrd
        break
    end
    if (old != pkt_nmbr):
        textmsg(grp_move)
        a[0] = a[0] + b[0]
        a[1] = a[1] + b[2]
        a[2] = a[2] + b[1] 
        a[3] = b[3]
        a[4] = b[4]
        a[5] = b[5]
    end
    old = pkt_nmbr
    sync()
end
halt